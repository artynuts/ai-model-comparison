---
description: Best practices for mocking in tests
globs: *.test.tsx
alwaysApply: false
---

# Effective Mocking
- **Define mock functions at the module level** outside of test blocks for accessibility and verification.
- **Implement mocks that return consistent function references** rather than creating new functions each time.
- **Reset all mocks before each test** using `jest.clearAllMocks()` to prevent test contamination.
- **Verify calls using the module-level mock functions** instead of accessing through class instances.
- **Use mockResolvedValueOnce/mockReturnValueOnce** for test-specific behavior while maintaining default implementations.

## Class/Service Mocking
```typescript
// ✅ DO: Create module-level mock functions
const mockGetData = jest.fn();
const mockSaveData = jest.fn();

// ✅ DO: Return the same function references
jest.mock('../MyService', () => ({
  MyService: jest.fn(() => ({
    getData: mockGetData,
    saveData: mockSaveData
  }))
}));

// ✅ DO: Reset and set defaults before each test
beforeEach(() => {
  jest.clearAllMocks();
  mockGetData.mockResolvedValue(defaultData);
});

// ✅ DO: Verify using the module-level functions
expect(mockGetData).toHaveBeenCalledWith(expectedParams);

// ❌ DON'T: Access through mock instances
// const instance = (MyService as jest.Mock).mock.instances[0];
// expect(instance.getData).toHaveBeenCalled(); // Unreliable!
``` 